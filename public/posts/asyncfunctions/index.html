<!doctype html>







<html
  class="not-ready lg:text-base"
  style="--bg:"
  lang="en"
  dir="ltr"
><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Async Functions - Shivam Gupta</title>

  
  <meta name="theme-color" />

  <meta name="description" content="So I had to calls a server over a lakh times to get some output.
Then had to resort to async functions ( as I already has the list which I need to pass as input)
But some observations about how it works →
async def func()
{
}  
async def main():
{
tasks = [asyncio.create_task(func(i)) for i in range(10)]
await asyncio.gather(*tasks)
}
asyncio.run(main())
So what happens is → tasks makes list of all the numbers which need to be executed
and when asyncio.gather(*tasks) is called, it executes all of them in parallel." />
  <meta name="author" content="Shivam Gupta" /><link rel="preload stylesheet" as="style" href="http://localhost:1313/main.min.css" />

  
  <link rel="preload" as="image" href="http://localhost:1313/theme.png" />

  <link rel="preload" as="image" href="https://www.gravatar.com/avatar/a81bbaf54d8b4232f35a22cad694eaa6?s=160&amp;d=identicon" />

  <link rel="preload" as="image" href="http://localhost:1313/twitter.svg" /><link rel="preload" as="image" href="http://localhost:1313/github.svg" />

  <script
    defer
    src="http://localhost:1313/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>

  
  <link
    rel="icon"
    href="http://localhost:1313/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="http://localhost:1313/apple-touch-icon.png"
  />

  <meta name="generator" content="Hugo 0.148.2">
</head>
<body
    class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"
  ><header
  class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"
>
  <div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto">
    <a
      class="-translate-y-[1px] text-2xl font-medium"
      href="http://localhost:1313/"
      >Shivam Gupta</a
    >
    <div
      class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8"
    role="button"
    aria-label="Menu"
  ></div>

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = ''.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"
  ><nav
      class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"
    ><a
        class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal"
        href="/projects/"
        >Projects</a
      ><a
        class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal"
        href="/posts/"
        >Blog</a
      ><a
        class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal"
        href="/misc/"
        >Misc</a
      ></nav><nav
      class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"
    >
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/https://twitter.com/reversemagnus"
        target="_blank"
        rel="me"
      >twitter</a>
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/https://github.com/revmag"
        target="_blank"
        rel="me"
      >github</a>
    </nav>
  </div>
</header>
<main
      class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"
    ><article>
  <header class="mb-14">
    <h1 class="my-0! pb-2.5">Async Functions</h1><div class="text-xs antialiased opacity-60"></div></header>

  <section><p>So I had to calls a server over a lakh times to get some output.<br>
Then had to resort to async functions ( as I already has the list which I need to pass as input)</p>
<p>But some observations about how it works →</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>tasks <span style="color:#f92672">=</span> [asyncio<span style="color:#f92672">.</span>create_task(func(i)) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>)]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">await</span> asyncio<span style="color:#f92672">.</span>gather(<span style="color:#f92672">*</span>tasks)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>asyncio<span style="color:#f92672">.</span>run(main())
</span></span></code></pre></div><p>So what happens is → tasks makes list of all the numbers which need to be executed
and when asyncio.gather(*tasks) is called, it executes all of them in parallel.</p>
<blockquote>
<p>Pretty simple</p></blockquote>
<p>But, if you have to set a limit of how many things can be concurrent at the same time, use semaphore, like this →</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>sem <span style="color:#f92672">=</span> asyncio<span style="color:#f92672">.</span>Semaphore(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>tasks <span style="color:#f92672">=</span> [asyncio<span style="color:#f92672">.</span>create_task(func(sem, i)) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>)]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">await</span> asyncio<span style="color:#f92672">.</span>gather(<span style="color:#f92672">*</span>tasks)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>asyncio<span style="color:#f92672">.</span>run(main())
</span></span></code></pre></div><p>But the questions arises, does the semaphore pass the next variables  after complete execution of the functions triggered by the first batch of numbers, or does it keep passing once it encounters a await function there ( and passes the missing space to semaphore)</p>
<p>So, yeah - it waits for the whole function to be executed, and then it passes the control to next numbers in the list, it holds the  semaphore until it completes the task and then releases it</p>
<p>Semaphore ensures at most N tasks( limit of semaphore) are actively executing at any given moment, and that’s the difference between let’s say batch processing, it will wait for the whole batch to be executed before moving on to the next batch.</p>
<p>So, if you have to use async for very large numbers:
Semaphore can be used, with let’s say a limit of 3-4
And if length of semaphore is bigger, let’s say around 10, and functions complete pretty fast, so sleep can be used, sleep timer of 1 will ensure that there is atleast a gap of 1 seconds between any N calls to the same server( given the server can handle N requests at a same time, and no more)</p>
<p>And more robust ways can be to induce callback, like if some errors come due to some functions, so just store it and make another call to it.</p>
<p>Updates : Async function doesn’t actually run multiple lines of code at the same time, async runs a block of code at a time, so it’s not entirely parallel programming( actual parallel programming is using multiprocess- which in reality runs multiple lines of code)
Single thread handles all tasks but switches if some tasks are waiting ( I/O or sleep timer)
But it can send multiple I/O requests at the same time.
<strong>Reality</strong>: From a CPU perspective, only one line of code is being executed at a time, but it feels like multiple tasks are progressing because the program &ldquo;yields&rdquo; control during I/O or waits.
It is has different meaning if run on Javascript vs Python ( difference as in - wait while I run this code vs aaah, I yield control ( and mostly functions in python are not designed to give control) )</p>
<p>There&rsquo;s another thing called event loop, which is inbuilt in javascript, but in python it needs to be created and then run.</p>
<p>I don&rsquo;t exactly understand running one block at a time, event loop, yield control but rough picture is : tasks are like things on queue, and when one gets executed other comes up ( vs just one entity in a loop - like in for loop), event loop is just which manages this whole infra, yield control I don&rsquo;t know.</p>
</section>

  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  ><a class="ltr:pr-3 rtl:pl-3" href="http://localhost:1313/posts/vivit/"
      ><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Understanding ViViT and how Videos are being encoded</span></a
    ><a
      class="justify-end pl-3 ltr:ml-auto rtl:mr-auto"
      href="http://localhost:1313/posts/stocks/"
      ><span>Stock Market Prediction with RNN</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    ></nav></article></main><footer
  class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"
>
  <div class="mr-auto">© Shivam Gupta</div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >powered by hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >hugo-paper</a
  >
</footer>
</body>
</html>
